// import some utilities, assumes Toolbox Commons, Toolbox Commons C, 
// and Slicing Toolbox are installed and active on the shell
// add Toolbox Commons utilities (FormattedSourceCorrespondence)
// add Toolbox Commons utilities for C/C++ programs
// add edge definitions for slicing/taint analysis
import com.ensoftcorp.open.commons.utilities._
import com.ensoftcorp.open.c.commons.analysis.CommonQueries._
import com.ensoftcorp.open.slice.analysis.ControlDependenceGraph
import com.ensoftcorp.open.slice.analysis.DataDependenceGraph

// get callers of strcpy and strlen
var strcpy = functions("strcpy")
var strlen = functions("strlen")
var callEdges = edges(XCSG.Call)
var strcpyCallers = callEdges.predecessors(strcpy)
var strlenCallers = callEdges.predecessors(strlen)

// show a rough guess of where vulnerable functions might be
show(strcpyCallers.intersection(strlenCallers), "Callers of strcpy and strlen, guessing secure")
show(strcpyCallers.difference(strlenCallers), "Callers of strcpy and not strlen, guessing insecure")

// create a program dependence graph for taint analysis
// note assumes "control-dependence" and "data-dependence" edges were added by slicing toolbox
var taint = universe.edgesTaggedWithAny(ControlDependenceGraph.CONTROL_DEPENDENCE_EDGE, DataDependenceGraph.DATA_DEPENDENCE_EDGE)

// assume attacker controlled inputs stem from the network socket
// find direct buffer writes that are tainted
var sockets = nodes(XCSG.Field).selectNode(XCSG.name, "socket")
var tainted = taint.forward(sockets)
var arrayWrites = nodes(XCSG.ArrayWrite)
var taintedArrayWrites = tainted.intersection(arrayWrites.containers())
show(taintedArrayWrites, "Tainted array writes")

// consider tainted indirect buffer writes occuring in stdlib, specifically strcpy
var invocationEdges = edges(XCSG.InvokedFunction)
var strcpyCallsites = invocationEdges.predecessors(strcpy)
var strcpyCallsiteStatements = strcpyCallsites.containers().nodes(XCSG.ControlFlow_Node)
var taintedStrcpyCallsites = tainted.intersection(strcpyCallsiteStatements)
show(taintedStrcpyCallsites, "Tainted strcpy Callsites")

// filter strcpy callsites by functions that do not call strlen
var taintedStrcpyCallsiteFunctions = taintedStrcpyCallsites.containers().nodes(XCSG.Function)
var potentiallyVulnerableFunctions = taintedStrcpyCallsiteFunctions.difference(strlenCallers)
show(potentiallyVulnerableFunctions, "Potentially Vulnerable App Functions")

// show and print the line number of the potentially vulnerable functions
// note: Filename: minishare\serve2.c (line 229) is a true postitive
var taintedStrcpyCallsitesInPotentiallyVulnerableFunctions = taintedStrcpyCallsites.intersection(potentiallyVulnerableFunctions.contained().nodes(XCSG.ControlFlow_Node))
show(taintedStrcpyCallsitesInPotentiallyVulnerableFunctions, "Potentially Vulnerable strcpy Callsite")
println(FormattedSourceCorrespondence.getSourceCorrespondents(taintedStrcpyCallsitesInPotentiallyVulnerableFunctions))